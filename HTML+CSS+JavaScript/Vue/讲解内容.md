# 讲解内容

## 排序：快速排序和归并排序

### 快速排序

前置条件：了解递归和冒泡排序

是由冒泡排序优化而来的

> 3  1  4 2 5
>
>1 3 4 2 5 		1  3 2 4 5  			
>
>1 2 3 4 5
>
>1 2 3 4 5
>
>1 2 3 4 5 

`a[i] = a[j]    a[j] = a[i] `完全错误



冒泡排序：n*n/2

```c
for(int i = 0; i < n - 1; i ++){
	for(int j = 0; j < n - i - 1; j ++){
		if(a[j]>a[j+1]){
			int t = a[j];
			a[j] = a[j+1];
			a[j+1] = t;
		}
	}
}
```

冒泡排序的事件复杂度为$O(n^2)$

斐波那契额

```c
#include<stdio.h>
int f(int n){
    if(n==1) return 1;
    else return n*f(n-1);
}
int main(){
 	printf("%d",f(5));
    return 0;
}
```



>f5:			return 5*f(4);				60
>
>f4:			return 4*f(3);				12
>
>f3:			return 3*f(2);				6
>
>f2:			return 2*f(1);				2
>
>f1:			return 1;

快速排序平均时间复杂度是$nlog{n}$，最坏也是$n^2$

`l+r>>1相当于(l+r)/2`

```c
int a[100010];
void qSort(int l, int r){
    if(l>=r) return;
    int i = l-1, j = r+1;
    int x = a[l+r>>1];
    while(i<j){
        do i++;while(a[i]<x);
        do j--;while(a[j]>x);
        if(i<j){
            int t = a[i];
            a[i] = a[j];
            a[j] = t;
        }
    }
    qSort(l,j);
    qSort(j+1,r);
}
```

递归进行操作



## 二分

比如在1~100个数你随机说一个数，使用二分就在很短的次数找到

适用于已经有序的情况

二分板子：（数组序号是0，n-1， l = 0, r = n-1）

```c
while(l<r){
    int mid = l+r>>1;
    if(check(mid)) l = mid;
    else r = mid-1;
}
```

当然这个模板是有一定缺陷的，比如陷入死循环之类，就需要考虑`边界条件`。比如，可能会有刚好满足的情况，即mid = l，这时候就需要考虑清楚了

还有一种不用考虑边界问题的板子

l = -1, r = n

```c
while(l+1!=r){
    int mid = l+r>>1;
    if(check(mid)) l = mid;
    else r = mid;
}
```

[P2249 【深基13.例1】查找 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P2249)



## 高精度





## 差分和前缀和