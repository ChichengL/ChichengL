# 浏览器工作原理笔记

## 进程VS线程

进程：是程序的一个运行实例。

线程：不能单独存在，依附在进程上的一个完成任务的执行路径。

两者的关系：一个进程可以包含多个线程，一个线程只能服务于一个进程。

多线程模式，极大的提高了浏览器对任务的处理速度。

特点：任何一个线程都是不可或缺的，如果出错，整个进程都会随之崩溃。（2）对于同进程的不同线程，可以共享进程的数据（3）当一个进程关闭之后，操作系统会回收进程所占用的内存（4）进程之间的内容相互隔离，以免因为一个页面崩溃而影响其他不相干的页面崩溃



目前Chrome浏览器进程

![img](https://static001.geekbang.org/resource/image/b6/fc/b61cab529fa31301bde290813b4587fc.png)

浏览器主进程：主要管控页面显示，用户交互等，还有存储功能。

网络进程：负责页面的网络资源加载等。

GPU进程：绘制页面。起初是为了绘制3D CSS

渲染进程：将HTML、CSS、JavaScript等代码转化为用户可以交互的页面。该进程是在沙箱模式下进行的，为了安全。

插件进程：负责插件的运行。

PS：沙箱模式：给运行程序外面套一个盒子，不影响其正常运行，但是会阻止其不安全行为，例如在硬盘上随意的写入任何数据，读取敏感位置的数据等。早期的浏览器插件可以用c\c++来写，因此可以访问系统下任何资源并且操作，具有极大的安全隐患。



我认为，推动浏览器发展的主要动力：安全性，流畅度，轻便程度。主要是这三个方向



## 数据的传递

要满足传递数据，那么必须符合网络协议（简称IP）。数据是以数据包的形式传递，而且如果数据包较大，那么会分散成很多小的数据包，进行传递。

访问网站的实质：一台计算机向另一台计算机请求信息。

IP地址：一台计算机的地址。在A向B发送数据包时，数据包会加上IP头，以存储A的IP地址（数据包发送的地方）和B的IP地址（数据包到达的地方）等其他信息。

如果还需要精确，比如送到哪个程序上，那么需要基于基于IP之上开发能和应用打交道的协议，常见的是`用户数据包协议`，简称UDP（User Datagram Protocol），其最重要的信息是端口号。

IP通过IP地址信息把数据包发送给指定的电脑，而UDP通过端口号把数据包分发给正确的程序。就类似快递，IP是哪个地址，而UDP是决定给哪个人。

缺点：在使用UDP发送数据时，有各种因素会导致数据包出错，虽然UDP可以校验数据是否正确，但是对于错误的数据包，UDP并不提供重发机制，只是丢弃当前的包，而且UDP在发送之后也无法知道是否能达到目的地。UDP不能保证数据可靠性，但是传输速度却非常快。

大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而UDP协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件。



TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，对于数据包丢失的情况，TCP提供重传机制；此外，TCP引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。



*   IP负责把数据包送达目的主机。
*   UDP负责把数据包送达具体应用。
*   而TCP保证了数据完整地传输，它的连接可分为三个阶段：建立连接、传输数据和断开连接。





## HTTP协议

建立在TCP协议之上的一种允许浏览器向服务器获取资源的协议，是Web的基础。同样也是浏览器使用最为广泛的协议。HTTP的内容是通过TCP的传输数据阶段来实现

域名和IP地址有着一一对应的关系，是通过域名系统（Domain Name System，即DNS）来进行建立的关系。所以在访问域名的时候通过DNS获取到域名对应的IP地址，进而传输数据。DNS还有缓存功能，即访问过的网站，在下次查询的时候直接使用而不是再去发起一个网络请求

有时候输入网址，不加www.开头也能进入相应的网址，是因为重定向。

二次页面打开很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据。

DNS缓存和页面资源缓存。



浏览器中的HTTP请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备IP和端口、等待TCP队列、建立TCP连接、发起HTTP请求、服务器处理请求、服务器返回请求和断开连接。





## URL到页面展示



用户输入：1.输入判定是URL还是搜索内容             2.URL请求过程：重定向（可能有）   响应数据类型处理（判断是文本类型text/html还是下载类型application/octet-stream）		3.准备渲染进程（同一域名下会在一个渲染进程里面）			4.提交文档（更新前进后退状态，更新安全状态，更新URL地址，更新Web页面）			5.渲染阶段

重定向可能有是因为，如果本身协议是https但是输入只是写了http那么就会重定向，然后返回真正需要到的域名在location里面

此外,如果多个页面的根域名相同，那么使用的是一个渲染进程



## 渲染流程

1.DOM生成（需要构建DOM树，浏览器无法直接理解和使用HTML）			2.样式计算（1.将CSS转化为styleSheets      2.标准化属性值比如 2em转化为32px			3.计算DOM树中每个节点 的样式，样式是会从父节点继承的）					3.布局（生成布局树，也就是真正需要展示的结构，比如有些结构有`display:none`那么布局树里面就不会生成该节点     再进行布局计算，计算出每个节点的坐标位置）			4.分层（渲染引擎需要为特点节点生成专用的图层，并且生成一颗对应的图层树，比如有`层叠上下文`（z-index，明确定位，滤镜属性filter:blur   透明度opacity）的就需要，需要剪裁（clip,比如说超出显示区域就隐藏）的地方也会创建图层）    5.图层绘制（会将一个个图层的绘制拆分为很多小指令，按着绘制列表进行绘制）			6.栅格化（绘制列表由主线程到合成线程之后，合成线程将图层划分为图块，合成线程会按照视口附近的图块（最小的栅格化单位）来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图，渲染进程维护了一个栅格化的线程池）   7.发送命令（一旦所有图块都被光栅化，合成线程会生成绘制图块的命令DrawQuad给浏览器进程）8.生成页面并显示（viz组件然后根据该命令将页面内容绘制在内存中，最后再将内存显示在屏幕上）



渲染流程里面，在通过构建DOM树和计算层叠样式表之后，根据这两个，创建布局树，如果某个节点存在display：none，那么根本在布局树中找到该节点。如果是visible:hidden那么还是会在布局树中找到，只不过在后面图层绘制里面不进行绘制。

修改常规流中元素的display通常会造成文档重排，这是因为元素的消失和出现会影响到页面的布局。而修改visibility属性只会造成本元素的重绘，即元素的视觉表现发生变化，但不会影响到页面的布局

 

## 变量提升

对于var，和函数，他们都会提升到当前作用域的顶部

对于JS而言并不是严格按照，代码的声明顺序执行的

```js
var t = 'hhh'
//可以拆解为   var t   t = 'hhh'，那么对于前部分就会提升在当前作用域的顶部
```

![](https://static001.geekbang.org/resource/image/ce/d5/cefe564dbff729e735a834fd9e3bd0d5.png)

代码执行之前会先编译，编译时，var声明的变量和函数会放在环境变量中，然后代码执行时，再从环境变量中找相应的代码

每调用一个函数，JavaScript引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后JavaScript引擎开始执行函数代码。

## 块级作用域

ES6之前不支持块级作用域，那么就有个弊端，var声明的变量会提升到当前作用域的顶部，那么预想和实际的输出就不一致了

```js
var a = 1
function test(){
    console.log(a)
    if(0){
        var a = 2
    }
}
test()
```

执行test函数后，先查看是否有var声明和函数声明，有的化，会提升到顶部。

那么实际上是

```js
var a
function test(){
	var a
	console.log(a)
	if(0){
		a = 2
	}
}
a = 1
test()
```

那么打印出来是`undefined`

还有类似于下面

```js
for(var i = 0; i < 10; i ++){}
console.log(i)//10
```

var创建的会提升到当前作用域顶部，那么就没有消失

因此在`ES6`就引出了const 和 let 还有块级作用域，那么在块级作用域生成的let和const不会影响外部的代码。

在编译阶段，通过var声明的内部变量是在变量环境，let和const声明的在词法环境。

词法环境是一个小型的栈，当该作用域完成时，这个栈就清空，那么在使用该变量时，会沿着一条路径进行查找<img src="https://static001.geekbang.org/resource/image/06/08/06c06a756632acb12aa97b3be57bb908.png" style="zoom:80%;" />

这样子去查找



## 作用域链和闭包

作用域链：按着位置进行查找声明变量的链式结构，从局部上下文查找到全局上下文为止。

`词法作用域`就是指作用域是由代码中`函数声明的位置`来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。

那么比如

```js
let time = 0
function test1(){
    let time = 1
    function test2(){
        console.log(time)
    }
    test2()
}
test1()//打印1
```

```js
let time = 0
function test1(){
    let time = 1
    test2()
}
function test2(){
    console.log(time)
}
test1()//打印0
```

这里就跟词法作用域有关。

第一段代码，test2是在test1里面声明的。然后那么test2的`outer（即外部引用）`指向test1的执行上下文，如果找不到，再取到test1的outer。

第二段代码，test2是在全局执行上下文中声明的，那么他的outer指向全局执行上下文。



闭包：

```js
function foo() {
    var myName = "极客时间"
    let test1 = 1
    const test2 = 2
    var innerBar = {
        getName:function(){
            console.log(test1)
            return myName
        },
        setName:function(newName){
            myName = newName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName("极客邦")
bar.getName()
console.log(bar.getName())
```

这是一段闭包代码。**根据词法作用域的规则，内部函数getName和setName总是可以访问它们的外部函数foo中的变量**

那么当foo函数执行完成后本应该销毁的内容，因为getName和setName而保留下来从而形成了闭包![](https://static001.geekbang.org/resource/image/ee/3f/ee7c1ca481875ad4bdeb4383bd1f883f.png)

成了这种情况。

闭包的定义：**在JavaScript中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是foo，那么这些变量的集合就称为foo函数的闭包**

闭包通常是直到页面关闭才消失

闭包：当会一直使用，作为全局闭包最好；如果使用频率不高而且占用内存大，那么作为局部闭包最好，这样当这个局部销毁时，闭包也会跟着销毁

或者像上面那个闭包，让bar = null，那么foo闭包没有指向它的东西，就会被回收。



```js
var bar = {
    myName:"time.geekbang.com",
    printName: function () {
        console.log(myName)
    }    
}
function foo() {
    let myName = "极客时间"
    return bar.printName
}
let myName = "极客邦"
let _printName = foo()
_printName()
bar.printName()
```

这段代码就不会产生闭包，bar.printName声明不在foo内部，那么根据词法作用域，foo里面的变量根本不会保存，因此不会产生闭包，那么其打印结果映射，极客邦*2



## this

在Javascript的对象中调用的方法要使用对象中的属性需要使用到this，指向该实例，this和执行上下文有关系，上下文分为，全局上下文，函数执行上下文和eval执行上下文

全局上下文的this指向window对象

在默认情况下，调用函数的this指向的时全局对象（浏览器中是window，NodeJs里面是globalThis）

### call

可以通过call进行设置this指向，而且call是直接执行

```js
let bar = {
  myName : "极客邦",
  test1 : 1
}
function foo(){
  this.myName = "极客时间"
}
foo.call(bar)
console.log(bar)
console.log(myName)
```

foo.call(bar)，将foo的this指向变为bar，并且执行。那么bar的myName被更改，bind和apply也相类似

bind()会创建一个新的函数，新函数被调用时，bind的第一个参数作为this（不会立即执行）

```js
var obj = {  
  x: 10  
};  
  
function printX() {  
  console.log(this.x);  
}  
  
var func = printX.bind(obj); // 创建一个新的函数，将`this`绑定到`obj`  
func(); // 输出：10
```

`apply()`方法会调用一个具有给定`this`值的函数，并以一个数组（或类似数组对象）作为函数的参数。，`apply()`需要一个对象作为第一个参数来设置函数的`this`值，然后提供一个数组作为函数的参数。

```js
var obj = {  
  x: 10,  
  y: 20  
};  
  
function printXY(x, y) {  
  console.log(this.x + this.y + x + y);  
}  
  
printXY.apply(obj, [100, 200]); // 输出：330
```



### 通过对象调用设置

`使用对象来调用其中的一个方法，该方法指向对象本身的。`但是如果使用全局变量，将对象中的方法赋值给它，那么在调用它的时候其内部的this指向全局变量

比如`obj.print()`那么在print里面打印this，this指向的是`对象的`，实际上Javascript引擎在执行`obj.print()`时默认的转化为了`obj.print().call(obj)`

```js
let bar = {
    name:123,
    print: function () { 
        console.log(this);
    }
}

bar.print();//{ name: 123, print: [Function: print] }
```

但是如果改为箭头函数，那么就是打印`{}`箭头函数没有this，那么他会套用上一层的this指向

### 通过构造函数设置

```js
function createObj = {
    this.name = '123'
}
var obj = new createObj()
```

这里面的this指向createObj的实例对象

<ul>
    <li>先创建一个空对象temObj</li>
    <li>接着调用CreateObj.call方法，并将tempObj作为call方法的参数，这样当CreateObj的执行上下文创建时，它的this就指向了tempObj对象；</li>
    <li>然后执行CreateObj函数，此时的CreateObj函数执行上下文中的this指向了tempObj对象；</li>
    <li>最后返回tempObj对象。</li>
</ul>



this的缺陷：嵌套函数的this不能继承，普通函数的this指向全局对象

```js
var myObj = {
  name : "极客时间", 
  showThis: function(){
    console.log(this)
    function bar(){console.log(this)}
    bar()
  }
}
myObj.showThis()
```

这里面bar的this指向window，而showThis的this指向对象。

改进方法：在bar外面声明self赋值为this，然后让里面不再调用this而是self。

2.使用箭头函数，箭头函数没有this，那么当使用时，会沿着作用域链向外部查找，直到找到this



## 栈空间和堆空间

在运行过曾在需要检测数据类型的语言称为动态语言，JavaScript就是一个动态语言。

同时JavaScript也是弱类型语言（支持隐式转化的）。

Boolean，Null,Undefined,Number，BigInt，String，Symbol这几种属于**基本类型**，声明时存储在栈中

Object属于**引用类型**，声明时存储在堆当中，栈中存储了相应的地址。Array是特殊的Object

之间闭包那里，是调用函数之后产生了闭包对象



深拷贝数组或者对象：

1.利用JSON字符串的转化

```js
function copy(src){
    return JSON.parse(JSON.stringify(src)) 
}
```

2.递归处理

```js
function copy(src){
    let dest = Array.isArray(src) ? [] : {}
    // 实现拷贝代码，将src的值完整地拷贝给dest
    // 在这里实现
    let keys = Object.keys(src)
    for (let i = 0; i < keys.length; i++){
        if (typeof src[keys[i]] === 'object') {
            dest[keys[i]] = copy(src[keys[i]])
        } else {
            dest[keys[i]] = src[keys[i]]
        }
    }
    return dest
    // return JSON.parse(JSON.stringify(src))
}
```

或者这样子简化一下

```js
function copy(src){
    if (src === null || typeof src !== 'object') {
        return src
    }
    const dest = Array.isArray(src) ? [] : {}
    for (let key in src) {
        dest[key] = copy(src[key])
    }
    return dest
}
```



如果遇到循环引用

```js
let obj = {
    name:'张三',
}
obj.sub = obj
```

比如上述情况就需要处理无限递归

```js
let obj = {
    name:'张三',
    likes:{
        dog:{
            name:'wangcai',
            age:1
        },
        cat:{
            name:'mimi',
            age:3
        }
    }
}
obj.sub = obj
let newObj = deepClone(obj)

function deepClone(value){
	let cache = new WeakMap()
    function _deepClone(value){
        if(value===null || typeof value !== 'object'){
            return value;
        }
        if(cache.has(value)){
            return cache.get(value)
        }
        const result = Array.isArray(value)?[]:{}
        for(let key in value){
            result[key] = _deepClone(value[key])
        }
        return result
    }
    return _deepClone(value)
}
```





## 垃圾回收

当函数执行上下文被销毁时，里面的内存会被垃圾回收机制自动回收。在调用栈里面存在，`存在当前执行状态的指针`（ESP），当某函数执行完成，ESP就会下移，因此销毁之前函数执行上下文。<img src="https://static001.geekbang.org/resource/image/b8/f3/b899cb27c0d92c31f9377db59939aaf3.jpg" style="zoom:80%;" />

这就是栈里面的垃圾回收

堆里面的垃圾数据，需要用到Javascript中的垃圾回收器

**待际假说**：第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；第二个是不死的对象，会活得更久。

在V8中会把堆分为**新生代**和**老生代**两个区域，**新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象**。

新生代存储空间较小，通常只有1-8M，老生代空间就大得多。

V8使用不同垃圾回收器，新生代使用副垃圾回收器，老生代使用主垃圾回收器

垃圾回收器的工作流程：**标记**活动对象与非活动对象（不再使用的对象，如何判定不再使用，那么就看是否有地址指向这片空间，如果没有那么就算是非活动对象）

2.统一回收非活动对象的内存。

3.做好内存管理。回收后，都是内存碎片，不连续。如果需要使用连续的大内存这样就出现了问题，因此需要做好内存管理。**But**有些回收器不会产生内存碎片。

#### 副垃圾回收器

一般比较小的对象是分配到新生区

新生代用Scavenge算法处理，将其分为对象区域和空闲区域。新加入的对象，分配到对象区域，当对象区域快满时，就会执行垃圾回收操作。当标记完成后，副垃圾回收器会将存活的对象复制到空闲区域，并且有序的进行排列，这就完成了内存管理，复制后空闲区域没有内存碎片，然后再将对象空间和空闲空间进行翻转。经过**两次**垃圾清理后**仍然存活**的对象就会**晋升**到老生区



#### 主垃圾回收器

一般比较大的对象会直接分配到老生区。因此老生区对象要不是比较大，要不就是存活时间长。因为对象可能比较大，如果使用Scavenge算法效率较低，因此使用的**标记-清除**算法。

标记从一组根元素开始，递归遍历，能达到的元素为活动对象，遍历整个不能达到为非活动对象。（遍历整个调用栈去查找）

标记整理算法，是标记完先不清楚，先整理再进行清楚操作

全停顿：Javascript执行垃圾回收算法时Javascript的脚本会停下来，等待回收之后再去执行。

为了降低老生代的垃圾回收造成的卡顿，V8会将标记过程分为一个个子标记过程，让标记过程和Javascript应用逻辑交替运行，直至**标记完成阶段**，这样的是增量标记



## V8的执行机制

编译器和解释器

类似c++类型的就是编译型语言,需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了

而JavaScript这样的是解释性语言在每次运行时都需要通过解释器对程序进行动态解释和执行

![](https://static001.geekbang.org/resource/image/4e/81/4e196603ecb78188e99e963e251b9781.png)

#### V8执行JS

V8将JavaScript代码生成AST和上下文

先分词,即词法分析，将一行行源码拆解为token，比如var算一个token。再解析，即语法分析，通过上面的token生成语法AST

开始时，没有字节码，都是使用的机器码，但是在手机上占用内存太高，然后重构了架构，变成了使用**字节码**，字节码需要通过解释器解释之后变为机器码然后被执行

<img src="https://static001.geekbang.org/resource/image/1a/ae/1af282bdc4036096c03074da53eb84ae.png" style="zoom:80%;" />

当解释器Ignition发现了热点代码（一段代码被重复执行多次），那么TurboFan就会直接将其转变为机器码，以提升代码效率

字节码配合解释器和编译器这种技术叫做**及时编译（JIT）**



## 消息队列和事件循环

想要在线程运行过程中，能接收并执行新的任务，就需要`事件循环机制`

<img src="https://static001.geekbang.org/resource/image/e2/c6/e2582e980632fd2df5043f81a11461c6.png" style="zoom:80%;" />

**渲染进程专门有一个IO线程用来接收其他进程传进来的消息**

消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列

为了保证效率和实时性，将DOM更新添加到当前宏任务中的微任务队列

微任务是：一种异步任务，包括Promise的回调、MutationObserver 的回调（检测DOM的变化）等，微任务会在当前宏任务结束后，下一个宏任务执行前执行。

优势：控制流程（可以在未来任意时间操作），异步操作（不会阻塞主线程），优先级调度（微任务具有更高的优先级），同步执行（紧接着宏任务执行），控制并发（可以使用Promise.all()确保完成所有微任务之后再执行下一个宏任务）



## setTimeout的实现

调用setTimeout设置回调函数，渲染进程将会创建一个回调任务，包含了回调函数showName、当前发起时间、延迟执行时间。消息队列中有ProcessDelayTask。

```c
struct DelayTask{
  int64 id；
  CallBackFunction cbf;
  int start_time;
  int delay_time;
};
DelayTask timerTask;
timerTask.cbf = showName;
timerTask.start_time = getCurrentTime(); //获取当前时间
timerTask.delay_time = 200;//设置延迟执行时间
```

id就是使用定时器返回的id，以便清除它。

setTimeout嵌套使用超过五次以上，那么系统设置最短时间间隔为4ms

未激活的页面，setTimeout执行最小间隔是100ms

延迟执行时间最大值：2147483647毫秒，大于时溢出，相当于延时设置为0

setTimeout设置的回调函数使用this不太好，但是如果需要有两种方法：

1.将使用对象的方法放入匿名函数中

```js
setTimeout(()=>{
	MyObj.showName()
},1000)
```

2.使用bind进行绑定

```js
setTimeout(MyObj.showName().bind(Myobj),1000)
```



## XMLHttpRequest的实现

XMLHttpRequest实现了从Web服务器获取数据的能力，得到数据后再通过DOM操作更新页面内容，这样就能实现页面更新而且不打扰用户

回调函数callback是在主函数doWork返回之前执行的，我们把这个回调过程称为**同步回调**。回调函数在主函数外部执行的过程称为**异步回调**。