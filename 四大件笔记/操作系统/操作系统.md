# 操作系统

怎么`变态`:

![image-20231117190630877](C:%5CUsers%5C%E5%90%83%E6%A9%99%E4%B8%8D%E5%90%83%E9%99%88%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231117190630877.png)

![image-20231117190833764](C:%5CUsers%5C%E5%90%83%E6%A9%99%E4%B8%8D%E5%90%83%E9%99%88%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231117190833764.png)

内核态>用户态:执行一条特权指令--修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权

用户态>内核态:由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权

![image-20231117192146480](C:%5CUsers%5C%E5%90%83%E6%A9%99%E4%B8%8D%E5%90%83%E9%99%88%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231117192146480.png)

陷入指令并非一个特权指令。别名：trap指令，访管指令，会主动将cpu返还给系统内核

（了解）原语：一种特殊的程序，必须一次性执行完毕 



#### 大内核和微内核

![image-20231117192636093](C:%5CUsers%5C%E5%90%83%E6%A9%99%E4%B8%8D%E5%90%83%E9%99%88%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231117192636093.png)

大内核和微内核的特点

![image-20231117192820339](C:%5CUsers%5C%E5%90%83%E6%A9%99%E4%B8%8D%E5%90%83%E9%99%88%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231117192820339.png)

## 进程与程序：

进程是程序实体执行一次的结果，是系统进行资源分配和调度的一个独立单位

进程的动态性：是进程最基本的特性。

进程的独立性：进程能独立运行、`独立获得资源、独立接收调度的基本单位`!!!!!

引入线程之后，进程就`不再是`接收调度的基本单位，但是仍然是独立获取资源的基本单位





各种状态的变化

![image-20231118085739631](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118085739631.png)

![image-20231118085846736](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118085846736.png)

两种方式，链式更多

![image-20231118090002658](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118090002658.png)

![image-20231118090022491](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118090022491.png)



#### 进程控制

实现进程控制使用`原语`，原语不可被打断，因为如果打断可能出现某些关键信息不统一。

可以使用`开中断`和`关中断`这两个指令实现原子性

原语有：创建原语，撤销原语，阻塞原语，唤醒原语（与阻塞原语成对使用），切换原语（让两个进程的状态发生改变）

![image-20231118103306090](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118103306090.png)



例如创建原语：

进程创建原语是操作系统中的一种特殊功能，其目标是为新进程创建一个PCB（进程控制块）。以下是其主要工作内容：

申请PCB、分配资源、初始化PCB、将PCB挂到就绪队列上

1. 申请一个空闲的PCB结构，作为新进程的控制信息存储。
2. 根据父进程所提供的参数，将子进程的PCB初始化，包括进程名、父进程标识符、处理器初始状态、进程状态、进程优先级、进程对应程序入口地址、资源申请和分配情况等信息。
3. 将新进程的PCB插入就绪队列，等待进程调度。

这样，新进程就可以在系统内进行活动并被有效地控制和管理。

#### 进程间通信：

两个进程之间产生数据交互（IPC，Inter-Process Communication）

![image-20231118103601980](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118103601980.png)

进程的内存地址各自独立，因此需要操作系统来进行处理。各个进程对于共享存储区的访问应该是`互斥`的（为了防止出错），可以使用（P，V操作）。

- #### 共享存储

    - 基于`存储区`的共享：操作系统只负责划分共享区域，数据的形式，存放类型都由程序自身决定，非常自由！！！`高级通信方式`。

    - 基于`数据结构`的共享：比如只能放置一个长度为10的数组，限制很多，`低级通信`

    - ![image-20231118104412712](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118104412712.png)

- #### 消息传递

    - ![image-20231118104518902](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118104518902.png)
    - 直接通信方式![image-20231118104756285](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118104756285.png)
    - 间接通信方式![image-20231118105008784](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118105008784.png)

- #### 管道通信方式

    - 管道只能是`单向`的，而且满足先进先出，取数据只能取出先进入的数据![image-20231118105204327](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118105204327.png)
    - ![image-20231118105818058](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118105818058.png)

![image-20231118110738393](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118110738393.png)





#### 线程：

- ![image-20231118111241739](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118111241739.png)
- cpu的基本执行单位。当出现线程之后，进程只作为除cpu外的系统`资源`的分配单位，但`不再是`接收调度的基本单位了。**线程是接收调度的基本单位**，几乎不会占用系统资源
    - 引入线程的变化：![image-20231118111655069](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118111655069.png)
    - 线程的属性![image-20231118111721754](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118111721754.png)

- 线程的实现方式

    - #### 用户级线程![image-20231118112117467](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118112117467.png)

    - 用户级线程相关问题<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118112324643.png" alt="image-20231118112324643" style="zoom:50%;" /><img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118112441673.png" alt="image-20231118112441673" style="zoom:50%;" />

    - #### 内核级线程![image-20231118112720893](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118112720893.png)

    - 相关问题<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118112822774.png" alt="image-20231118112822774" style="zoom:50%;" /><img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118112905350.png" alt="image-20231118112905350" style="zoom:50%;" />

    - #### 多线程模型

        - 一对一模型<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118113053153.png" alt="image-20231118113053153" style="zoom:80%;" />
        - 多对一模型![image-20231118113338080](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118113338080.png)
        - 多对多模型![image-20231118113541817](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118113541817.png)

    ![image-20231118113700176](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118113700176.png)

## 处理机调度

<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118114241740.png" alt="image-20231118114241740" style="zoom: 50%;" />

调度：当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定`某种规则`来`决定`处理这些任务的`顺序`，这就是“调度”研究的问题。

作业：一个具体的任务 ≈ 用户让操作系统启动一个程序

高级调度![image-20231118114635258](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118114635258.png)

低级调度![image-20231118114705771](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118114705771.png)

进程调度是操作系统中**最基本的一种调度**，在一般的操作系统中都必须配置进程调度。
进程调度的**频率很高**，一般几十毫秒一次。

`中级调度(内存调度)`--按照某种策略决定将哪个处于`挂起状态`的进程重新调入内存
一个进程可能会被多次调出、调入内存，因此`中级调度`发生的`频率`要比高级调度`更高`。

- 挂起状态：细分为就绪挂起，和阻塞挂起
- 七状态模型![image-20231118115159781](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118115159781.png)
- 三种调度的对比<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118122720780.png" alt="image-20231118122720780" style="zoom: 50%;" />

进程调度的时机：

<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118123708983.png" alt="image-20231118123708983" style="zoom:80%;" />

临界资源，临界区： 临界区有普通临界区和内核临界区

![image-20231118124326971](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118124326971.png)

#### 进程调度方式

抢占式和非抢占式

抢占式：可以优先处理更紧急的进程，也可以实现让各种进程按时间片轮流执行的功能。适用于分时操作系统、实时操作系统

非抢占式：实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统

进程切换主要完成：

+ 对原来运行进程各种数据的保存
+ 对新的进程各种数据的恢复

注意:**进程切换是有代价的**，因此如果**过于频繁的**进行进程调度、切换，必然会使整个   ，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。

#### 评价调度算法的指标

- cpu利用率
    - cup忙绿时间占总时间的比例
    - 利用率 = $忙绿时间/ 总时间$

- 系统吞吐量
    - 单位时间内完成作业的数量
    - 系统吞吐量 = $总共完成了多少道作业/总共花了多少时间$

- 周转时间：
    - 从**作业被提交给系统开始**，到**作业完成为止**的这段时间间隔
    -  等待被调度的时间+进程在继续队列上等待进程调度的时间+进程在cpu上执行的时间+进程等待I/O操作完成的时间（后面三个可以统括为执行时间）
    - 周转时间 = 作业完成时间  -   作业提交时间
    - 平均周转时间 = `各作业周转时间之和 / 作业数`
    - **带权周转时间** = $作业周转时间/作业实际运行的时间$ = $(作业完成时间- 作业提交时间)/作业实际运行的时间$
    - 平均带权周转时间 = $各作业带权时间之和/作业数$

- 等待时间：处于等待处理机状态时间之和。是进程建立之后**等待被服务的时间之和**f

#### 调度算法

算法思想，算法规则，用于作业调度还是进程调度，抢占式和非抢占式，优缺点， 是否饥饿（长期得不到服务）

- 先来先服务（FCFS，First come First Serve）
    - ![image-20231118133619998](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118133619998.png)
- 短作业优先（SJF,Shortest Job First ）
    - 注意细节![image-20231118134500716](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118134500716.png)
    - ![image-20231118134604279](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118134604279.png) 
- 高响应比优先（HRRN）
    - 是先来先服务算法和短作业优先算法的结合，既考虑了等待时间又考虑了运行时间![image-20231118135450378](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118135450378.png)

- 三者对比![image-20231118135540801](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118135540801.png)

- 时间片轮转调度（RR）
    -    时间片不能太大也不能太小（20ms~50ms） ![image-20231118140702143](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118140702143.png)
- 优先级调度算法 
    - ![image-20231118141344211](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118141344211.png)

- 多级反馈队列调度算法
    - 其他调度算法的这种权衡![image-20231118164008426](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118164008426.png)

上面三种适用于交互系统

## 同步互斥

知识点回顾:进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。

同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。

<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118172432321.png" alt="image-20231118172432321" style="zoom:50%;" />

我们把**一个时间段内只允许一个进程使用**的资源称为**临界资源**。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。

对临界资源的访问，必须**互斥**地进行。互斥，亦称**间接制约关系**。**进程互斥**指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。

<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118173232778.png" alt="image-20231118173232778" style="zoom:50%;" />

#### 进程互斥方法实现

- 单标志法：
    - 算法思想:两个进程在**访问完临界区后**会把使用临界区的权限转交给另一个进程。也就是说**每个进程进入临界区的权限只能被另一个进程赋予**
    - ![image-20231118173827040](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118173827040.png)
- 双标志先检查算法
    - 算法思想:设置一个布尔型数组 flag[]，数组中各个元素用来**标记各进程想进入临界区的意愿**，比如“flag[0] =ture”意味着0号进程 P0 现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志 flag[i] 设为 true，之后开始访问临界区
    - ![image-20231118174607644](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118174607644.png)
- 双标志后检查法：



#### 互斥锁

![Screenshot_2023-11-20-15-10-01-370_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-20-15-10-01-370_tv.danmaku.bil.jpg)

##### 信号量

![Screenshot_2023-11-20-15-24-02-810_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-20-15-24-02-810_tv.danmaku.bil.jpg)



![Screenshot_2023-11-20-15-27-37-121_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-20-15-27-37-121_tv.danmaku.bil-1700810636460.jpg)



![Screenshot_2023-11-20-15-29-57-205_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-20-15-29-57-205_tv.danmaku.bil.jpg)



![Screenshot_2023-11-20-15-37-47-364_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-20-15-37-47-364_tv.danmaku.bil.jpg)

信号量实现同步

![Screenshot_2023-11-20-15-46-49-448_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-20-15-46-49-448_tv.danmaku.bil.jpg)



执行顺序

![Screenshot_2023-11-20-15-50-22-038_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-20-15-50-22-038_tv.danmaku.bil.jpg)



![Screenshot_2023-11-20-16-07-20-437_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-20-16-07-20-437_tv.danmaku.bil.jpg)



![Screenshot_2023-11-20-16-01-30-805_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-20-16-01-30-805_tv.danmaku.bil-1700810773778.jpg)

多生产者多消费者

![Screenshot_2023-11-21-16-15-22-696_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-21-16-15-22-696_tv.danmaku.bil.jpg)

单独一个信号量的时候

![Screenshot_2023-11-21-16-22-24-842_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-21-16-22-24-842_tv.danmaku.bil.jpg)



![Screenshot_2023-11-21-16-22-47-579_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-21-16-22-47-579_tv.danmaku.bil.jpg)



![Screenshot_2023-11-21-16-23-26-251_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-21-16-23-26-251_tv.danmaku.bil-1700811133207.jpg)



哲学家就餐问题

![Screenshot_2023-11-21-17-29-42-857_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-21-17-29-42-857_tv.danmaku.bil.jpg)



![Screenshot_2023-11-21-17-29-48-825_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-21-17-29-48-825_tv.danmaku.bil.jpg)

读者，写者问题

![Screenshot_2023-11-21-17-09-59-569_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-21-17-09-59-569_tv.danmaku.bil.jpg)

管程（防止多种信号量杂乱不堪）

![Screenshot_2023-11-21-17-42-19-737_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-21-17-42-19-737_tv.danmaku.bil.jpg)



![Screenshot_2023-11-21-17-52-33-985_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-21-17-52-33-985_tv.danmaku.bil.jpg)





## 死锁

#### 基本概念

![image-20231127163511140](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127163511140.png)

![image-20231127163539842](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127163539842.png)





区别：

- 死锁:各进程互相等待对方手里的资源，导致**各进程**都阻塞，无法向前推进的现象。
- 饥饿:由于长期得不到想要的资源，**某进程**无法向前推进的现象。比如: 在短进程优先(SPF)算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”
- 死循环:**某进程执行过程中一直跳不出某个循环的现象**。有时是因为程序逻辑 bug 导致的，有时是程序员故意设计的。
- ![image-20231127163650607](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127163650607.png)



死锁产生的条件（缺一不可，四个）

- **互斥条件**:只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备)。象内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等待这种资源)。
- 不剥夺条件:进程所获得的资源在未使用完之前，**不能由其他进程强行夺走**，只能主动释放。
- 请求和保持条件:**进程已经保持了至少一个资源**，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。
- 循环等待条件:**存在一种进程资源的循环等待链**，链中的每一个进程已获得的资源同时被下一个进程所请求。

注意!**发生死锁**时**一定有循环等待**，但是**发生循环等待时未必死锁**(循环等待是死锁的必要不充分条件)

死锁的发生时机：

<ol>
    <li>对系统资源的竞争。各进程对不可剥夺的资源(如打印机)的竞争可能引起死锁，对可剥夺的资源 (CPU)的竞争是不会引起死锁的。</li>
    <li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1.P2分别申请并占有了资源 R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1,两者会因为申请的资源被对方占有而阻塞，从而发生死锁</li>
    <li>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。 (可以把互斥信号量、同步信号量也看做是一种抽象的系统资源)</li>

​    

#### 死锁的处理

- ##### 预防死锁（不允许死锁发生，静态策略）

    - <img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127165907579.png" alt="image-20231127165907579" style="zoom:50%;" />

    - 互斥条件:只有对必须互斥使用的资源的争抢才会导致死锁。

        - 该策略的缺点:并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件。

    - 不剥夺条件:进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。

        - 方案一:当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。
        - 方案二:当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级(比如:剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用)

        - 缺点：![image-20231127170640414](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127170640414.png)

    - 请求和保持条件: 进程**已经保持了至少一个资源**，但又提出了新的资源**请求**，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持**不放**。

        - 可以采用**静态分配方法**，即进程在运行前**一次申请完它所需要的全部资源**，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源o
        - 该策略实现起来简单，但也有明显的缺点:有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的**资源浪费，资源利用率极低**。另外，该策略也有可能导致某些**进程饥饿**。

    - 循环等待条件:存在一种进程资源的**循环等待链**，链中的每一个进程已获得的资源同时被下一个进程所请求。

        - 可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源(即编号相同的资源) 一次申请完。
        - 原理分析:一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。
        - ![image-20231127170928104](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127170928104.png)

- ##### 避免死锁！！（著名算法：银行家算法）

    - 安全序列：所谓安全序列，就是指如果系统按照**这种序列分配资源**，则每个进程**都能**顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。

        - 如果分配了资源之后，系统中**找不出任何一个**安全序列，系统就进入了`不安全状态`。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有`可能重新回到安全状态`，不过我们在分配资源之前总是要考虑到最坏的情况。
        - 如果系统处于`安全状态`，就一定`不会`发生死锁。如果系统进入`不安全状态`，就`可能`发生死锁(处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态)
        - 因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这世是“银行家算法”的核心思想

    - 银行家算法：银行家算法是荷兰学者 Dikstra 为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，用于**避免死锁**。

        - **核心思想**:在进程提出资源申请时，先**预判此次分配**是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。

        - ![image-20231127171355391](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127171355391.png)
        - ![image-20231127171610849](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127171610849.png)每次使用完，都会归还资源
        - ![image-20231127172733747](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127172733747.png)

- ##### 死锁的检测和解除（允许死锁的发生）

    - 死锁检测算法:用于检测系统状态，以确定系统中是否发生了死锁
- 死锁解除算法:当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。
    - ![image-20231127173719716](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127173719716.png)
    - 死锁的检测![image-20231127175548571](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127175548571.png)
    - ![image-20231127175740094](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127175740094.png)
    - 死锁的解除![image-20231127180028673](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127180028673.png)



## 内存

### 内存的基础知识

- <img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127184602703.png" alt="image-20231127184602703" style="zoom:50%;" />
- 内存可存放数据。程序执行前**需要先放到内存中才能被CPU处理**--缓和CPU与硬盘之间的速度矛盾
- ![image-20231127185032986](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127185032986.png)

### 内存管理

- 操作系统需要完成的：![image-20231127191913019](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127191913019.png)
    - 内存保护：
        - 设置上下限寄存器![image-20231127192001089](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127192001089.png)
        - 重定位寄存器![image-20231127192116003](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127192116003.png)
        - ![image-20231127192218845](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127192218845.png)

#### 覆盖与交换

- ![image-20231127192444054](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127192444054.png)
- 覆盖技术：![image-20231127192707238](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127192707238.png)
- 交换技术：交换(对换)技术的设计思想:内存空间紧张时，系统将内存中某些进程暂时**换出**外存，把外存中某些已具备运行条件的进程**换入**内存(进程在内存与磁盘间动态调度)
- 暂时换出外存等待的进程状态为**挂起状态** (挂起态，suspend)挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态
- ![image-20231127194048744](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127194048744.png)

### 内存的分配与回收

#### 连续分配

**连续分配**:指为用户进程分配的必须是一个**连续的**内存空间

连续分配管理方式：单一连续，固定分区，动态分区

- 单一连续分配
    - 在单一连续分配方式中，内存被分为系统区和用户区系统区通常位于内存的低地址部分，用于存放操作系统相关数据:用户区用于存放用户进程相关数据。内存中**只能有一道用户程序**，用户程序独占整个用户区空间。
    - 优点:实现简单;**无外部碎片**;可以采用覆盖技术扩充内存;不一定需要采取内存保护 (eg: 早期的 PC操作系统MS-DOS)
    - <img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203120420127.png" alt="image-20231203120420127" style="zoom:67%;" />
    - 缺点: 只能用于单用户、单任务的操作系统中**;有内部碎片**;存储器利用率极低。    tip：分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片“
- 固定分区分配
    - 20世纪60年代出现了支持多道程序的系统，为了能在内存中**装入多道程序**，且这些程序之间又**不会相互干扰**，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式
    - <img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203120700418.png" alt="image-20231203120700418" style="zoom:33%;" /><img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203120718140.png" alt="image-20231203120718140" style="zoom: 50%;" />
    - 分区大小相等: 缺乏灵活性，但是很**适合用于用一台计算机控制多个相同对象的场合** (比如: 钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序)
    - 分区大小不等:增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分(比如: 划分多个小分区、适量中等分区、少量大分区)
    - 如何实现：操作系统需要建立一个数据结构--**分区说明表**，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的**大小、起始地址、状态(是否已分配)**。![image-20231203121056490](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203121056490.png)
    -  优点:实现简单，无**外部碎片**。
    - 缺点:a.当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用**覆盖技术**来解决，但这又会降低性能:b.会产生内部碎片，内存利用率低。
- 动态分区
    - **动态分区分配**又称为**可变分区分配**。这种分配方式**不会预先划分内存分区**，而是在进程装入内存时**根据进程的大小动态地建立分区**，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。 (eg:假设某计算机内存大小为64MB，系统区8MB，用户区共56 MB...
    - ![image-20231203121531910](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203121531910.png)
    - 当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配?把一个新作业装入内存时，须按照一定的**动态分区分配算法**，从空闲分区表(或空闲分区链)中选出一个分区分配给该作业。由于分配算法算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。
    - 动态分区分配没有内部碎片，但是有外部碎片。
        **内部碎片**，分配给某进程的内存区域中，如果有些部分没有用上。
        **外部碎片**，是指内存中的某些空闲分区由于太小而难以利用。
    - 如果内存中空闲空间的总和本来可以满足某进程的要求但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。可以通过**紧凑**(拼凑，Compaction) 技术来解决外部碎片，相当于移位，将进程分配的内存空间变得连续起来

#### 动态分区分配算法

- 首次适应算法（First Fit）
    - 算法思想:每次都从**低地址**开始查找，找到**第一个**能满足大小的空闲分区
    - 如何实现: 空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分 区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。
    - <img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203122652781.png" alt="image-20231203122652781" style="zoom:50%;" />

- 最佳适应算法（Best Fit）
    - 算法思想:由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区即，优先使用更小的空闲区。
    - 如何实现:空闲分区**按容量递增次序链接**。每次分配内存时顺序查找**空闲分区链**(或**空闲分区表**)，找到大小能满足要求的**第一个空闲分区**
    - <img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203122931108.png" alt="image-20231203122931108" style="zoom:50%;" />
    - 缺点: 每次都选最小的分区进行分配，**会留下越来越多的、很小的、难以利用的内存块**。因此这种方法会产生很多的外部碎片。
- 最坏适应算法（Worst Fit）
    - 又称为最大适应算法
    - 算法思想:为了解决最佳适应算法的问题一一即留下太多难以利用的小碎片，可以在每次分配时**优先使用最大的连续空闲区**，这样分配后剩余的空闲区就不会太小，更方便使用。
    - 如何实现:空闲分区按**容量递减次序链接**。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。
    - <img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203123517336.png" alt="image-20231203123517336" style="zoom:50%;" />
    - 缺点: 每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致**较大的连续空闲区被迅速用完**。如果之后**有“大进程”到达，就没有内存分区可用了**

- 邻近适应算法（Next Fit）
    - 算法思想:首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。
    - 如何实现:空闲分区以**地址递增的顺序排列** (可排成一个循环链表)。每次分配内存**时从上次查找结束的位置**开始**查找空闲分区链** (或空闲分区表)，找到大小能满足要求的第一个空闲分区。
    - 优点：首次适应算法每次都要从头查找，每次都需要检索低地址的小分区但是这种规则也决定了当低地址部分有更小的分区可以满足需求时会更有可能用到低地址部分的小分区，也会** **最佳适应算法的优点) 
    - 缺点：邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后**导致无大分区可用** (最大适应算法的缺点)

![image-20231203124130402](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203124130402.png)

 

#### 非连续分配管理方式

##### 基础概念

为用户进程分配的key是一些分散的内存空间

分页存储：将内存空间分为一个个**大小相等的分区**(比如:每个分区4KB)，每个分区就是一个“页框”(**页框**=**页帧**=**内存块**=**物理块**=**物理页面**)。每个页框有一个编号，即“**页框号**”(页框号=页帧号=内存块号=物理块号=物理页号)，页框号从0开始

将`进程的逻辑地址空间`也分为与**页框大小相等**的一个个部分每个部分称为一个“**页**”或“**页面**”。每个页面也有一个编号即“**页号**”，**页号也是从0开始**。

操作系统**以页框为单位为各个进程分配**内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的**页面**与内存的页框有一一对应的关系。
各个页面不必连续存放，可以放到不相邻的各个页框中。

<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203124909016.png" alt="image-20231203124909016" style="zoom:67%;" />

<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203125054751.png" alt="image-20231203125054751" style="zoom:50%;" />

页，页面：进程逻辑地址空间与页框大小相同的部分

页框，页帧，物理页，物理块：操作系统将内存划分的一个个大小相等的分区

**地址结构**：

 分页存储管理的逻辑地址结构如图所示：

| 页号P | 页内偏移量W |
| ----- | ----------- |
|       |             |

​    地址结构包含两部分，前一部分为页号P，后一部分为页内偏移量W。地址长度为32位。其中0 - 11位为页内地址，即每页大小为4KB，12~31位为页号（逻辑地址空间），即最多允许2^20页存在。

​    注意地址结构决定了虚拟内存的寻址空间有多大，在实际问题中页号、页内偏移量、逻辑地址可能是用十进制数给出的，若题目用二进制地址的形式给出时，读者要学会转换。

为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张**页表**            注:页表通常存在PCB(进程控制块)中

 ![image-20231203125345311](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203125345311.png)



- 每个页表项占多少字节

<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203125509608.png" alt="image-20231203125509608" style="zoom:67%;" />

  由于**页号**是隐含的，因此**每个页表项占3B**，存储整个页表至少需要3*(n+1)B

- 如何实现地址的转化 
    - 特点：虽然进程的各个页面是离散存放的，但是页面内部是连续存放的
    -  <img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203130633904.png" alt="image-20231203130633904" style="zoom:50%;" />
    - <img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203130752901.png" alt="image-20231203130752901" style="zoom:50%;" />
    -  **页号** = 逻辑地址 / 页面长度（取整）		  = 逻辑地址%页面长度（取余）
    - ![image-20231203131111044](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203131111044.png)
    - 结论:如果每个页面大小为 $2^k$B，用二进制数表示逻辑地址则**末尾K 位**即为**页内偏移量**，其余部分就是**页号**
    - 结论:如果页面大小刚好是2的整数幂，则只需把页表中记录的**物理块号**拼接上**页内偏移量**就能得到对应的**物理地址**
    
    页表项与地址结构都由两部分组成，而且第一部分都是页号，但是**页表项的第二项**是由**物理块号**组成的，也就是进程对应内存当中的物理块号（页框号），但是**地址结构**的第二部分确是由**页内偏移量**构成的。**页表项的第二部分物理块号与地址结构的第二部分页内偏移量共同构成物理地址。**
    
    **页内偏移量也就是页号**
    
    地址长度为![img](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/wps1.jpg) 位，其中![img](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/wps2.jpg) 位为页内地址，即每页大小为![img](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/wps3.jpg) ； ![img](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/wps4.jpg) ![img](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/wps5.jpg) 位为页号，地址空间最多允许![img](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/wps6.jpg) 页。

##### 基本地址变化机构

通常会在系统中设置一个**页表寄存器** (PTR)，存放**页表在内存中的起始地址F** 和**页表长度M**。进程未执行时，页表的始址 和 页表长度 **放在进程控制块 (PCB)中**，当进程被调度时，操作系统内核会把它们放到页表寄存器中。



从逻辑地址到物理地址的流程 

![image-20231203132244400](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203132244400.png)



 ![image-20231203132643174](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203132643174.png)

例题：![image-20231203134123565](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203134123565.png)

在分页存储管理(页式管理)的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，**页式管理中地址是一维的**。即，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量 两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位。

结论:理论上，页表项长度为 3B 即可表示内有块号的范围，但是，为了方便页表的查询，常常会让一个页表项占更多的字节，使得**每个页面恰好可以装得下整数个页表项**。（因此一般页表项的长度为4b，那么一个页表就有1024号页表项），如果出现页表项的长度最小为多少，那么就计算，先算出总共多少内存块 = 系统物理内存 / 页面大小，然后算出来是2的多少次方，就占多少bit，比如 $2^{20} -1$个物理块，那么，需要20个进制位，每8个进制位为一字节，那么至少需要3个字节



##### 具有快表的地址变换机构

基本地址变换机构的改进版本

**快表**，又称**联想寄存器** (**TLB**， translation lookaside buffer ) ，是一种访问速度比内存快很多的高速缓存(**TLB不是内存!)**，用来存放**最近访问的页表项的副本**，可以加速地址变换的速度与此对应，内存中的页表常称为**慢表**

<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203135426756.png" alt="image-20231203135426756" style="zoom:50%;" />

进程切换的时候快表会被清空  

<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203140101386.png" alt="image-20231203140101386" style="zoom:50%;" />





##### 两级页表

单级页表的问题：<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203140906593.png" alt="image-20231203140906593" style="zoom: 50%;" />



问题一:**页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框**。

解决：<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203141148639.png" alt="image-20231203141148639" style="zoom:50%;" />



问题二:没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面

- ![image-20231203141348924](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203141348924.png)
- ![image-20231203141502328](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203141502328.png)
- ![image-20231203141758513](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203141758513.png)
-  ![image-20231203141907940](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203141907940.png)

细节：<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203142158801.png" alt="image-20231203142158801" style="zoom:50%;" />

计算页面数量= 1级页表域数量 *  2级页表域数量 * ...  * n级页表域数量

比如：一个32为地址的计算机使用两级页表。虚拟地址被分为9位的顶级页表域，11位二级页表域和一个偏移量，在地址空间中一共有多少页面

>顶级页表域的数量为 $2^9$ 二级页表域的数量为 $2^{11}$故地址空间中的页面数量为  $2^{11} * 2 ^ 9 = 2^{20}$

##### 基本分段存储管理方式

与分页最大的区别就是——离散分配时所分配地址空间的基本单位不同

进程的地址空间: 按照程序**自身的逻辑**关系**划分为若干个段**，每个段都有一个段名(在低级语言中，程序员使用段名来编程)，每段从0开始编址

内存分配规则:以段为单位进行分配，**每个段在内存中占据连续空间**，但**各段之间可以不相邻**。

分段系统的逻辑地址结构由段号(段名) 和段内地址(段内偏移量)所组成。

<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203142706035.png" alt="image-20231203142706035" style="zoom:50%;" />

段号的位数**决定了每个进程最多可以分几个段**

**段内地址位数**决定了每个段的**最大长度是多少** 

段表类似于页表 

![image-20231203145450494](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203145450494.png)

 

![image-20231203165829891](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203165829891.png)

分页和分段的**对比**

页是信息的`物理单位`。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，`对用户是不可见的`。

段是信息的`逻辑单位`。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段`对用户是可见的，`用户编程时需要显式地给出段名。

页的大小**固定**且由**系统决定**。段的长度却不固定，决定于用户编写的程序

**分页**的用户进程**地址空间是一维的**，程序员只需给出一个记忆符即可表示一个地址。

**分段**的用户进程**地址空间是二维的**，程序员在标识一个地址时，既要给出段名，也要给出段内地址。

**分段**比分页更容易实现信息的共享和保护 

![image-20231203170419175](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203170419175.png)

  

访问一个逻辑地址需要几次访存?
**分页**(**单级页表**):第一次访存--查内存中的页表，第二次访存--访问目标内存单元。总共**两次访存**

**分段**:第一次访存一-查内存中的段表，第二次访存一一访问目标内存单元。总共**两次访存**与分页系统类似，分段系统中也**可以引入快表机构**，将近期访问过的段表项放到快表中，这样**可以少一次访问**，加快地址变换速度。

##### 段页式管理方式

分页和分段的优缺点：

![image-20231203171106876](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203171106876.png)

进程按照逻辑模块分段，再将各段分页

<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203171652361.png" alt="image-20231203171652361" style="zoom:50%;" />

每个段对应一个段表项，每个段表项由段号、**页表长度**、**页表存放块号(页表起始地址)** 组成。每个**段表项长度相等，段号是隐含的**。

每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的。

<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231203172054357.png" alt="image-20231203172054357" style="zoom:50%;" />

 每个进程只有一个段表，但是一个段表项对应一个页表（因此一个进程可能有多个页表）

![image-20231204182357197](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204182357197.png)





#### 内存空间的扩充

##### 虚拟内存

传统存储方式的特征、缺点

- ![image-20231204182808473](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204182808473.png)

- 一次性:**作业必须一次性全部装入内存后才能开始运行**。这会造成两个问题: 作业很大时，不能全部装入内存，导致**大作业无法运行**:@当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，**导致多道程序并发度下降**。
- 驻留性:一旦作业被装入内存，就**会一直驻留在内存中**，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源
- 局部性原理
    - 时间局部性:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行:如果某个数据
        被访问过，不久之后该数据很可能再次被访问。 (因为程序中存在大量的循环)
    - 空间局部性:一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。
        (因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的)

虚拟内存的定义与特征

- 基于局部性原理，在程序装入时，可以将程序中**很快会用到的部分装入内存**，**暂时用不到的部分留在外存**就可以让程序开始执行。
    在程序执行过程中，当所访问的**信息不在内存时**，由**操作系统负责将所需信息从外存调入内存**，然后继续执行程序。
- 若内存空间不够，由**操作系统**负责将**内存中暂时用不到的信息换出到外存**。在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是**虚拟内存**
- 主要特征
    - **多次性:**无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。
    - **对换性**:在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。
    - **虚拟性**:从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。
- 虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此虚拟内存的实现需要建立在**离散分配**的内存管理方式基础上。
- <img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204184129884.png" alt="image-20231204184129884" style="zoom:50%;" />



##### 请求分页存储管理

请求分页存储管理与基本分页存储管理的主要区别:

在程序执行过程中，当所**访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存**，然后继续执行程序。若内存空间不够，由操作系统负责**将内存中暂时用不到的信息换出到外存。**

![image-20231204184643651](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204184643651.png)

![image-20231204184810071](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204184810071.png)

**缺页中断**是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此**属于内中断条**，指令在执行期间，**可能产生多次缺页中断**。 (如:cpyAto B，即将逻辑地址A中的数据复制到罗辑地址B，而A、B属于不同的页面，则有可能产生两次中断)

![image-20231204185102616](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204185102616.png)

相比传统的分页存储管理，多出来几个步骤

<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204185242713.png" alt="image-20231204185242713" style="zoom:50%;" />

基本流程

<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204185355753.png" alt="image-20231204185355753" style="zoom:50%;" />

##### 页面置换算法

页面置换算法也就是，操作系统负责将内存中暂时用不到的数据换出到外存

主要分为四类（有点类似与动态分区算法）

缺页：只要进行了页面置换就会导致缺页次数增加

- 最佳置换算法（OPT）
    - 最佳置换算法(OPT，Optimal):每次选择**淘汰的页面**将是**以后永不使用**，或者**在最长时间内不再被访问的页面**这样可以保证最低的缺页率。
    - ![image-20231204190334414](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204190334414.png)
    - 这个例子中将1淘汰，是因为，从后面开始找，最先找到的是0,2，因此就淘汰1.
    - 但是这个缺点非常明显：最佳置换算法可以保证最低的缺页率，但实际上，**只有在进程执行的过程中才能知道接下来会访问到的是哪个页面**（比如你现在在场景B，左右分别是场景A，C，但是不能确定是否进入哪一个场景）。操作系统无法提前预判页面访问序列。因此，**最佳置换算法是无法实现的**。（序列未知）
- 先进先出（FIFO）
    - 先进先出置换算法 (FIFO): 每次**选择淘汰的**页面**是最早进入内存**的页面
    - 实现方法:把调入内存的页面根据调入的先后顺序排成**一个队列**，需要换出页面时选择队头页面即可队列的最大长度取决于系统为进程分配了多少个内存块
    - 例子：<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204191004072.png" alt="image-20231204191004072" style="zoom: 50%;" />
    - **Belady 异常**--当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。
    - **只有 FIFO 算法会产生 Belady 异常**。另外，FIFO算法虽然**实现简单**，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，**算法性能差**
- 最近最久未使用置换算法（LRU，least recently used）
    - 最近最久未使用置换算法(LRU、least recently used):每次淘汰的页面是**最近最久未使用的页面**
    - 实现方法: 赋予每个页面对应的页表项中，用**访问字段记录该页面自上次被访问以来所经历的时间t**。
        当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。
    - <img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204192842646.png" alt="image-20231204192842646" style="zoom:50%;" />
    - 在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。在**逆向扫描过程中最后个出现的页号就是要淘汰的页面**。
    - 该算法的实现需要专门的硬件支持，虽然**算法性能好**，但是**实现困难**，**开销大**
- 时钟置换算法（CLOCK）
    - 时钟置换算法是一种性能和开销较均衡的算法，又称**CLOCK算法**，或**最近未用算法**(NRU，Not Recently Used)
    - **简单的CLOCK 算法**实现方法:为每个页面设置**一个访问位**，再将内存中的页面都通过链接指针**链接成1个循环队列**。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出:如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描(第二轮扫描中一定会有访问位为0的页面，因此**简单的CLOCK 算法**选择一个淘汰页面**最多**会经过**两轮扫描**) 
    - 缺点：**简单的时钟置换算法**仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过就不需要执行VO操作写回外存。**只有被淘汰的页面被修改过时，才需要写回外存。**
        因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。**在其他条件都相同时，应优先淘汰没有修改过的页面**，避免/0操作。这就是改进型的时钟置换算法的思想。**修改位=0**，表示页面**没有**被修改过;**修改位=1**，表示页面被**修改过**。
        为方便讨论，用**(访问位，修改位)**的形式表示各页面状态。如(1，1)表示一个页面近期被访问过，且被修改过。
    - ![image-20231204194841598](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204194841598.png)

##### 页面分配策略

**驻留集**:指请求分页存储管理中给进程分配的物理块的集合<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204195308286.png" alt="image-20231204195308286" style="zoom: 67%;" />

**固定分配:**操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，**驻留集大小不变**

**可变分配**:先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少即，**驻留集大小可变**

局部置换:发生缺页时只能选进程自己的物理块进行置换

全局置换: 可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。

<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204195614492.png" alt="image-20231204195614492" style="zoom:50%;" />

**固定分配局部置换**:系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略的缺点是:很难在刚开始就确定应为每个进程分配多少个物理块才算合理。 (采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数)

**可变分配全局置换**:刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程:若已无空闲物理块，则可选择1个**未锁定**的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，**只要某进程发生缺页都将获得新的物理块**，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个**被选中的进程拥有的物理块会减少，缺页率会增加。**

**可变分配局部置换**:刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许**从该进程自己的物理块中**选出一个进行**换出外存**。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度:反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。

<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204200242897.png" alt="image-20231204200242897" style="zoom:50%;" />

调入页面的时机问题

<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204200417796.png" alt="image-20231204200417796" style="zoom:50%;" />

从何处调入页面

![image-20231204200622274](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204200622274.png)

抖动（颠簸）现象

刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为**抖动**，或**颠簸**。产生抖动的**主要原因是**进程频繁访问的页面数目高于可用的物理块数(**分配给进程的物理块不够**)

**驻留集**:指请求分页存储管理中给进程分配的内存块的集合

**工作集**:指在某段时间间隔里，进程实际访问页面的集合。

![image-20231204200914893](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204200914893.png)



##### 内存映射文件

内存映射文件一一操作系统向上层程序员提供的功能(系统调用)

- 方便程序员访问文件数据
- 方便多个进程共享同一个文件

传统文件的访问方式

![image-20231204202601657](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204202601657.png) 

![image-20231204202818646](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204202818646.png)

内存映射文件的方便之处

![image-20231204202932462](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204202932462.png)

##  文件管理

文件属性（操作系统）

- 文件名：同一目录下不允许有重名文件
- 标识符：一个系统内的各文件标识符唯一，对用户来说毫无可读性,因此标识符只是操作系统用于区分各个文件的一种内部名称。
- 类型：文件的类型
- 大小，创建时间，上次修改时间，文件所有者信息
- 保护信息：对文件进行保护的访问控制信息

![image-20231204204953038](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204204953038.png)

![image-20231204205120524](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204205120524.png)



操作系统向上提供的功能：

- 创建文件：调用`create系统调用`
- 读文件：将文件数据读入内存，才能让cpu处理，调用`read系统调用`
- 写文件：将更改后的文件数据从内存写入外存中，调用`write系统调用`
- 删除文件：调用`delete系统调用`
- 打开文件，open系统调用
- 关闭文件，close系统调用

![image-20231204213928667](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204213928667.png)

### 文件的逻辑结构

无结构文件：无结构文件:文件内部的数据就是一系列二进制流或字符流组成。又称“流式文件”。如:windows 操作系统中的 .txt 文件。

有结构文件: 由一组相似的记录组成，又称“**记录式文件**”。每条记录又若千个数据项组成。如:数据库表文件。一般来说，每条记录有一个数据项可**作为关键字**(作为识别不同记录的ID)根据各条记录的长度(占用的存储空间) 是否相等，又可分为**定长记录**和**可变长记录**两种

![image-20231204220209115](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204220209115.png)



**顺序文件**:文件中的记录一个接、个地顺序排列(逻辑上)，记录可以是**定长**的或**可变长**的。各个记录在物理上可以**顺序存储**或**链式存储**。

![image-20231204221517201](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204221517201.png)

![image-20231204222232289](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231204222232289.png)