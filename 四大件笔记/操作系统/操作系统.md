# 操作系统

怎么`变态`:

![image-20231117190630877](C:%5CUsers%5C%E5%90%83%E6%A9%99%E4%B8%8D%E5%90%83%E9%99%88%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231117190630877.png)

![image-20231117190833764](C:%5CUsers%5C%E5%90%83%E6%A9%99%E4%B8%8D%E5%90%83%E9%99%88%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231117190833764.png)

内核态>用户态:执行一条特权指令--修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权

用户态>内核态:由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权

![image-20231117192146480](C:%5CUsers%5C%E5%90%83%E6%A9%99%E4%B8%8D%E5%90%83%E9%99%88%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231117192146480.png)

陷入指令并非一个特权指令。别名：trap指令，访管指令，会主动将cpu返还给系统内核

（了解）原语：一种特殊的程序，必须一次性执行完毕 



#### 大内核和微内核

![image-20231117192636093](C:%5CUsers%5C%E5%90%83%E6%A9%99%E4%B8%8D%E5%90%83%E9%99%88%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231117192636093.png)

大内核和微内核的特点

![image-20231117192820339](C:%5CUsers%5C%E5%90%83%E6%A9%99%E4%B8%8D%E5%90%83%E9%99%88%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231117192820339.png)

### 进程与程序：

进程是程序实体执行一次的结果，是系统进行资源分配和调度的一个独立单位

进程的动态性：是进程最基本的特性。

进程的独立性：进程能独立运行、`独立获得资源、独立接收调度的基本单位`!!!!!

引入线程之后，进程就`不再是`接收调度的基本单位，但是仍然是独立获取资源的基本单位





各种状态的变化

![image-20231118085739631](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118085739631.png)

![image-20231118085846736](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118085846736.png)

两种方式，链式更多

![image-20231118090002658](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118090002658.png)

![image-20231118090022491](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118090022491.png)



#### 进程控制

实现进程控制使用`原语`，原语不可被打断，因为如果打断可能出现某些关键信息不统一。

可以使用`开中断`和`关中断`这两个指令实现原子性

原语有：创建原语，撤销原语，阻塞原语，唤醒原语（与阻塞原语成对使用），切换原语（让两个进程的状态发生改变）

![image-20231118103306090](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118103306090.png)





#### 进程间通信：

两个进程之间产生数据交互（IPC，Inter-Process Communication）

![image-20231118103601980](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118103601980.png)

进程的内存地址各自独立，因此需要操作系统来进行处理。各个进程对于共享存储区的访问应该是`互斥`的（为了防止出错），可以使用（P，V操作）。

- #### 共享存储

    - 基于`存储区`的共享：操作系统只负责划分共享区域，数据的形式，存放类型都由程序自身决定，非常自由！！！`高级通信方式`。

    - 基于`数据结构`的共享：比如只能放置一个长度为10的数组，限制很多，`低级通信`

    - ![image-20231118104412712](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118104412712.png)

- #### 消息传递

    - ![image-20231118104518902](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118104518902.png)
    - 直接通信方式![image-20231118104756285](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118104756285.png)
    - 间接通信方式![image-20231118105008784](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118105008784.png)

- #### 管道通信方式

    - 管道只能是`单向`的，而且满足先进先出，取数据只能取出先进入的数据![image-20231118105204327](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118105204327.png)
    - ![image-20231118105818058](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118105818058.png)

![image-20231118110738393](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118110738393.png)





#### 线程：

- ![image-20231118111241739](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118111241739.png)
- cpu的基本执行单位。当出现线程之后，进程只作为除cpu外的系统`资源`的分配单位，但`不再是`接收调度的基本单位了。**线程是接收调度的基本单位**，几乎不会占用系统资源
    - 引入线程的变化：![image-20231118111655069](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118111655069.png)
    - 线程的属性![image-20231118111721754](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118111721754.png)

- 线程的实现方式

    - #### 用户级线程![image-20231118112117467](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118112117467.png)

    - 用户级线程相关问题<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118112324643.png" alt="image-20231118112324643" style="zoom:50%;" /><img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118112441673.png" alt="image-20231118112441673" style="zoom:50%;" />

    - #### 内核级线程![image-20231118112720893](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118112720893.png)

    - 相关问题<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118112822774.png" alt="image-20231118112822774" style="zoom:50%;" /><img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118112905350.png" alt="image-20231118112905350" style="zoom:50%;" />

    - #### 多线程模型

        - 一对一模型<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118113053153.png" alt="image-20231118113053153" style="zoom:80%;" />
        - 多对一模型![image-20231118113338080](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118113338080.png)
        - 多对多模型![image-20231118113541817](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118113541817.png)

    ![image-20231118113700176](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118113700176.png)

### 处理机调度

<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118114241740.png" alt="image-20231118114241740" style="zoom: 50%;" />

调度：当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定`某种规则`来`决定`处理这些任务的`顺序`，这就是“调度”研究的问题。

作业：一个具体的任务 ≈ 用户让操作系统启动一个程序

高级调度![image-20231118114635258](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118114635258.png)

低级调度![image-20231118114705771](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118114705771.png)

进程调度是操作系统中**最基本的一种调度**，在一般的操作系统中都必须配置进程调度。
进程调度的**频率很高**，一般几十毫秒一次。

`中级调度(内存调度)`--按照某种策略决定将哪个处于`挂起状态`的进程重新调入内存
一个进程可能会被多次调出、调入内存，因此`中级调度`发生的`频率`要比高级调度`更高`。

- 挂起状态：细分为就绪挂起，和阻塞挂起
- 七状态模型![image-20231118115159781](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118115159781.png)
- 三种调度的对比<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118122720780.png" alt="image-20231118122720780" style="zoom: 50%;" />

进程调度的时机：

<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118123708983.png" alt="image-20231118123708983" style="zoom:80%;" />

临界资源，临界区： 临界区有普通临界区和内核临界区

![image-20231118124326971](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118124326971.png)

#### 进程调度方式

抢占式和非抢占式

抢占式：可以优先处理更紧急的进程，也可以实现让各种进程按时间片轮流执行的功能。适用于分时操作系统、实时操作系统

非抢占式：实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统

进程切换主要完成：

+ 对原来运行进程各种数据的保存
+ 对新的进程各种数据的恢复

注意:**进程切换是有代价的**，因此如果**过于频繁的**进行进程调度、切换，必然会使整个   ，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。

#### 评价调度算法的指标

- cpu利用率
    - cup忙绿时间占总时间的比例
    - 利用率 = $忙绿时间/ 总时间$

- 系统吞吐量
    - 单位时间内完成作业的数量
    - 系统吞吐量 = $总共完成了多少道作业/总共花了多少时间$

- 周转时间：
    - 从**作业被提交给系统开始**，到**作业完成为止**的这段时间间隔
    -  等待被调度的时间+进程在继续队列上等待进程调度的时间+进程在cpu上执行的时间+进程等待I/O操作完成的时间（后面三个可以统括为执行时间）
    - 周转时间 = 作业完成时间  -   作业提交时间
    - 平均周转时间 = `各作业周转时间之和 / 作业数`
    - **带权周转时间** = $作业周转时间/作业实际运行的时间$ = $(作业完成时间- 作业提交时间)/作业实际运行的时间$
    - 平均带权周转时间 = $各作业带权时间之和/作业数$

- 等待时间：处于等待处理机状态时间之和。是进程建立之后**等待被服务的时间之和**f

#### 调度算法

算法思想，算法规则，用于作业调度还是进程调度，抢占式和非抢占式，优缺点， 是否饥饿（长期得不到服务）

- 先来先服务（FCFS，First come First Serve）
    - ![image-20231118133619998](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118133619998.png)
- 短作业优先（SJF,Shortest Job First ）
    - 注意细节![image-20231118134500716](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118134500716.png)
    - ![image-20231118134604279](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118134604279.png) 
- 高响应比优先（HRRN）
    - 是先来先服务算法和短作业优先算法的结合，既考虑了等待时间又考虑了运行时间![image-20231118135450378](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118135450378.png)

- 三者对比![image-20231118135540801](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118135540801.png)

- 时间片轮转调度（RR）
    -    时间片不能太大也不能太小（20ms~50ms） ![image-20231118140702143](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118140702143.png)
- 优先级调度算法 
    - ![image-20231118141344211](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118141344211.png)

- 多级反馈队列调度算法
    - 其他调度算法的这种权衡![image-20231118164008426](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118164008426.png)

上面三种适用于交互系统

### 同步互斥

知识点回顾:进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。

同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。

<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118172432321.png" alt="image-20231118172432321" style="zoom:50%;" />

我们把**一个时间段内只允许一个进程使用**的资源称为**临界资源**。许多物理设备(比如摄像头、打印机)都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。

对临界资源的访问，必须**互斥**地进行。互斥，亦称**间接制约关系**。**进程互斥**指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。

<img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118173232778.png" alt="image-20231118173232778" style="zoom:50%;" />

#### 进程互斥方法实现

- 单标志法：
    - 算法思想:两个进程在**访问完临界区后**会把使用临界区的权限转交给另一个进程。也就是说**每个进程进入临界区的权限只能被另一个进程赋予**
    - ![image-20231118173827040](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118173827040.png)
- 双标志先检查算法
    - 算法思想:设置一个布尔型数组 flag[]，数组中各个元素用来**标记各进程想进入临界区的意愿**，比如“flag[0] =ture”意味着0号进程 P0 现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志 flag[i] 设为 true，之后开始访问临界区
    - ![image-20231118174607644](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231118174607644.png)
- 双标志后检查法：



#### 互斥锁

![Screenshot_2023-11-20-15-10-01-370_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-20-15-10-01-370_tv.danmaku.bil.jpg)

##### 信号量

![Screenshot_2023-11-20-15-24-02-810_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-20-15-24-02-810_tv.danmaku.bil.jpg)



![Screenshot_2023-11-20-15-27-37-121_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-20-15-27-37-121_tv.danmaku.bil-1700810636460.jpg)



![Screenshot_2023-11-20-15-29-57-205_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-20-15-29-57-205_tv.danmaku.bil.jpg)



![Screenshot_2023-11-20-15-37-47-364_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-20-15-37-47-364_tv.danmaku.bil.jpg)

信号量实现同步

![Screenshot_2023-11-20-15-46-49-448_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-20-15-46-49-448_tv.danmaku.bil.jpg)



执行顺序

![Screenshot_2023-11-20-15-50-22-038_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-20-15-50-22-038_tv.danmaku.bil.jpg)



![Screenshot_2023-11-20-16-07-20-437_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-20-16-07-20-437_tv.danmaku.bil.jpg)



![Screenshot_2023-11-20-16-01-30-805_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-20-16-01-30-805_tv.danmaku.bil-1700810773778.jpg)

多生产者多消费者

![Screenshot_2023-11-21-16-15-22-696_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-21-16-15-22-696_tv.danmaku.bil.jpg)

单独一个信号量的时候

![Screenshot_2023-11-21-16-22-24-842_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-21-16-22-24-842_tv.danmaku.bil.jpg)



![Screenshot_2023-11-21-16-22-47-579_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-21-16-22-47-579_tv.danmaku.bil.jpg)



![Screenshot_2023-11-21-16-23-26-251_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-21-16-23-26-251_tv.danmaku.bil-1700811133207.jpg)



哲学家就餐问题

![Screenshot_2023-11-21-17-29-42-857_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-21-17-29-42-857_tv.danmaku.bil.jpg)



![Screenshot_2023-11-21-17-29-48-825_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-21-17-29-48-825_tv.danmaku.bil.jpg)

读者，写者问题

![Screenshot_2023-11-21-17-09-59-569_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-21-17-09-59-569_tv.danmaku.bil.jpg)

管程（防止多种信号量杂乱不堪）

![Screenshot_2023-11-21-17-42-19-737_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-21-17-42-19-737_tv.danmaku.bil.jpg)



![Screenshot_2023-11-21-17-52-33-985_tv.danmaku.bil](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/Screenshot_2023-11-21-17-52-33-985_tv.danmaku.bil.jpg)





### 死锁

#### 基本概念

![image-20231127163511140](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127163511140.png)

![image-20231127163539842](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127163539842.png)





区别：

- 死锁:各进程互相等待对方手里的资源，导致**各进程**都阻塞，无法向前推进的现象。
- 饥饿:由于长期得不到想要的资源，**某进程**无法向前推进的现象。比如: 在短进程优先(SPF)算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”
- 死循环:**某进程执行过程中一直跳不出某个循环的现象**。有时是因为程序逻辑 bug 导致的，有时是程序员故意设计的。
- ![image-20231127163650607](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127163650607.png)



死锁产生的条件（缺一不可，四个）

- **互斥条件**:只有对必须互斥使用的资源的争抢才会导致死锁(如哲学家的筷子、打印机设备)。象内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的(因为进程不用阻塞等待这种资源)。
- 不剥夺条件:进程所获得的资源在未使用完之前，**不能由其他进程强行夺走**，只能主动释放。
- 请求和保持条件:**进程已经保持了至少一个资源**，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。
- 循环等待条件:**存在一种进程资源的循环等待链**，链中的每一个进程已获得的资源同时被下一个进程所请求。

注意!**发生死锁**时**一定有循环等待**，但是**发生循环等待时未必死锁**(循环等待是死锁的必要不充分条件)

死锁的发生时机：

<ol>
    <li>对系统资源的竞争。各进程对不可剥夺的资源(如打印机)的竞争可能引起死锁，对可剥夺的资源 (CPU)的竞争是不会引起死锁的。</li>
    <li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1.P2分别申请并占有了资源 R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1,两者会因为申请的资源被对方占有而阻塞，从而发生死锁</li>
    <li>信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。 (可以把互斥信号量、同步信号量也看做是一种抽象的系统资源)</li>

​    

#### 死锁的处理

- ##### 预防死锁（不允许死锁发生，静态策略）

    - <img src="%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127165907579.png" alt="image-20231127165907579" style="zoom:50%;" />

    - 互斥条件:只有对必须互斥使用的资源的争抢才会导致死锁。

        - 该策略的缺点:并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安全，很多地方还必须保护这种互斥性。因此，很多时候都无法破坏互斥条件。

    - 不剥夺条件:进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。

        - 方案一:当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。
        - 方案二:当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级(比如:剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用)

        - 缺点：![image-20231127170640414](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127170640414.png)

    - 请求和保持条件: 进程**已经保持了至少一个资源**，但又提出了新的资源**请求**，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持**不放**。

        - 可以采用**静态分配方法**，即进程在运行前**一次申请完它所需要的全部资源**，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源o
        - 该策略实现起来简单，但也有明显的缺点:有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的**资源浪费，资源利用率极低**。另外，该策略也有可能导致某些**进程饥饿**。

    - 循环等待条件:存在一种进程资源的**循环等待链**，链中的每一个进程已获得的资源同时被下一个进程所请求。

        - 可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源(即编号相同的资源) 一次申请完。
        - 原理分析:一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。
        - ![image-20231127170928104](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127170928104.png)

- ##### 避免死锁！！（著名算法：银行家算法）

    - 安全序列：所谓安全序列，就是指如果系统按照**这种序列分配资源**，则每个进程**都能**顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。

        - 如果分配了资源之后，系统中**找不出任何一个**安全序列，系统就进入了`不安全状态`。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有`可能重新回到安全状态`，不过我们在分配资源之前总是要考虑到最坏的情况。
        - 如果系统处于`安全状态`，就一定`不会`发生死锁。如果系统进入`不安全状态`，就`可能`发生死锁(处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态)
        - 因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这世是“银行家算法”的核心思想

    - 银行家算法：银行家算法是荷兰学者 Dikstra 为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，用于**避免死锁**。

        - **核心思想**:在进程提出资源申请时，先**预判此次分配**是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。

        - ![image-20231127171355391](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127171355391.png)
        - ![image-20231127171610849](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127171610849.png)每次使用完，都会归还资源
        - ![image-20231127172733747](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127172733747.png)

- ##### 死锁的检测和解除（允许死锁的发生）

    - 死锁检测算法:用于检测系统状态，以确定系统中是否发生了死锁
- 死锁解除算法:当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。
    - ![image-20231127173719716](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127173719716.png)
    - 死锁的检测![image-20231127175548571](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127175548571.png)
    - ![image-20231127175740094](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127175740094.png)
    - 死锁的解除![image-20231127180028673](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.assets/image-20231127180028673.png)



### 内存

