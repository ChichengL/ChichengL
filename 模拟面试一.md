## 模拟面试

### 首先自我介绍

来自xx，xx专业，xxx。大一上干了什么，大一下干了什么。

如果有问学生科研实验室，优势是什么。专业指导老师提供科研项目，毕业学长学姐提供更多技术，以及各个公司的内推机会，此外团队里面有一群志同道合的朋友一起向一个方向前进。类似于我现在大二想寻找一份实习，也是在学长学姐们的推荐下进行尝试。

### 为什么选择前端方向？

根据大一下的不断摸索，发现自己对前端更加感兴趣。相较于后端，有可视化的窗口，以及一经调节就能看出的区别。

### html

还需要复习

### css

#### 如何实现类似于if-else一样的选择？

#### 如何去调节适配问题？

flex

#### position有哪几种？

absolute，relative，fixed，sticky（像京东上面的导航栏，华东）

#### z-index知道吗，谈谈你对他的理解。

分层，进行图层覆盖

#### 如果存在多个图层对于当前页面有什么影响？

造成页面卡顿，多个图层最终需要进行合并。尤其是每个图层都有动画的时候，合并时会占用大量的GPU进程（在浏览器渲染原理里面提及）。



### JS

#### 数据类型有哪些

基本数据类型：Number，String，Boolean（3常见），null，undefined（2为空），Symbol，BigInt（2新增，ES6）

引用数据类型：object

#### 你对于数组和object的看法？

数组是特殊的Object，数组的索引是下标。

#### 修改数组的7中方法：

push，pop，shift，unshift（4操作），sort，reverse，splice。

#### 既然谈到了splice，那么slice和splice有什么区别呢

slice是取数组中的某一段，不会修改元素组。

splice是对数组的“剪贴”，既可以新增，也可以删除，会修改原数组。

#### 声明长度为10，元素都是1数组的方法

1.for循环创建

```js
let arr = []
for(let i = 0; i < 10; i ++)
    {
        arr.push(1);
    }
```

2.new Array创建

```js
let arr = new Array(10).fill(1)
```

3.from创建

```js
let arr = Array.from({length:10},()=>1)
```

那么如何创建二维数组欸

```js
let arr = new Array(10).fill(new Array(10).fill(1))
```

**补充：**这种方法有缺陷，如果修改一处数组，那么会出现修改多处修改的现象。引申（谈自己的见解）：因为外层数组的元素都指向同一片地方，new Array(10).fiil(1)生成的数组空间，就相当于内部只声明了一个数组空间，而外层索引对应的值，都指向同一个地方。如何去避免：使用map迭代方法，会产生新的数组，因此改进应该是，

`let arr = new Array(10).fill().map(()=>new Array(10).fill(1))`

![image-20231018145444104](C:%5CUsers%5C%E5%90%83%E6%A9%99%E4%B8%8D%E5%90%83%E9%99%88%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231018145444104.png)

但是Array.from是没有这个缺陷的。

#### 你能说说数组中常见的迭代器吗？

forEach，map，reduce。

forEach和map的不同点，forEach不会返回新数组，而map会。

#### 你知道宏任务和微任务吗

宏任务，异步任务中的一种，像setTimeout，回调函数等。微任务：像Promise和mutationObserver()（监视DOM元素的变化）。

#### 浏览器如何执行js脚本的

通过网络进程加载资源，然后把整个脚本当作一个宏任务执行，在这其中，如果又遇到宏任务将其加入到消息队列末尾，遇到微任务就加入到微任务队列。然后当前宏任务执行完毕之后，直接查看微任务队列，如果不为空，则执行其中的内容，直到为空进行下一个宏任务，然后继续重复。

#### 你怎么理解的消息队列和事件循环

事件循环实质上是一个for循环，然后不断的从消息队列中取出任务并且执行。



#### 你知道js内存是什么样子的呢

js内存分为栈内存和堆内存，js中基本数据类型还有函数都是在调用栈中，而引用数据类型是存放在堆中。

堆又分为新生代和老生代。

#### 那你清楚垃圾回收的机制吗？

在调用栈中，当一个函数执行完成，如果没有产生闭包或者引用类型的话，内部的所有数据都会立刻被回收。

而在堆中，新生代和老生代的回收机制不同。新生代是通过scavenge算法将，其空间分为对象区和空闲区。当声明的对象较小时，是直接存放到新生代中，然后当新生代区快满前，会标记非活动对象，然后再将对象区中的数据翻转到空闲区中，并且在着过程中将非活动对象进行排序。清除之后，再翻转回去，这样就完成了垃圾回收。而且空闲出来的区域是连续的，保证了大型进程的运行。

经过两次回收后仍然存活的对象会晋升到老生代。声明较大的对象也是在老生代中。因此老生代不适用于scavenge算法，他有标记-清除算法和标记-整理算法，他俩有相同，都是先标记，不过前者是先清除非活动对象，然后再整理碎片空间，后者是先整理成连续的空间然后再进行清除。

#### 为什么需要整理空间

因为如果清除后不整理空间，那么即使剩余能够支撑某进程的空间，也可能导致进程不能运行，因为空间非连续。





### Vue框架

#### vue2是如何实现响应式数据的

vue2是通过defineProperty监视一个属性的取值和赋值操作，也属于基本操作之一。因此无法直接拦截数组的变化。

#### 那么Vue2如何实现拦截数组变化的

vue2对数组的方法实现了重写，然后将重写的方法放到**数组原型链**上，还有通过**set**进行监视数组添加值的监视。



#### Vue2和vue3在响应式数据上有什么区别？（自己添加的）

vue2是通过defineProperty实现的，Vue3是通过Proxy+reactive实现的。

vue2的defineProperty是由缺陷的，无法检测到数组，对象的变化，因为defineProperty也是基本操作之一。

vue3的是通过proxy和reflective实现的，操作时，操作的proxy代理对象，后面再通过reflective反射到源对象上。

proxy会拦截所有的基本操作，增删改等都能监测到。



#### vue3上的reflective的方法在object上都有，为什么？

算是一个设计缺陷，之前把所有方法都堆在object上，但是后面发现需要分类，因此诞生了更加健全的reflective。



#### 手写bind，call或者apply其中的一种

```js

Function.prototype.mycall = function (obj,...arguments) {
    obj.fn = this;
    obj.fn(...arguments);
    delete obj.fn;
    return this;
}
let obj = { name: '123' }
function test() {
    console.log(this.name);
}
test.mycall(obj)
```



