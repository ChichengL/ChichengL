# C++

> ## struct和class 的些许不同
>
> > /*struct 默认权限是公共的class 默认权限是**私有的**
> >
> > 成员属性设置为私有的好处 可以自己控制读写权限  对于写的可以检测数据的有效性
> >
> > struct 中可以有其他的struct 同样class里面也是可以的 
> >
> > */
>
> 假如 class Point{};那么如果要在**类外函数实现** 那么要表明作用域 如**void Point::setX(int x){m_x = x};**
>
> ## 访问权限
>
> > //访问权限
> >
> >  /*public 公共权限 成员 类内，类外都可访问
> >
> >  protected 保护权限 成员 类内可以访问，而类外不行 儿子也可以访问父亲的保护内容
> >
> >  private 私有权限 成员 类内可以访问，而类外不行  儿子不可以访问父亲的私有内容*/
>
> > **属性**  比如定义的各种类型变量
> >
> > **行为**  各种实现的函数
>
> 如果属性是**私有的**那么只能通过**public**中公有的函数来进行对属性进行操作
>
> ```c++
> class Person
> {
>   private:
>     int age;
>    public:
>     void setage(int a)
>     {
>         age = a;
>     }
>     int printage()
>     {
>         return age;
>     }
> };
> 
> int main()
> {
>     Person p;
>     p.setage(10);//正确的
>     p.age = 10//错误的,私有成员类外不可访问
> }
> ```
>
> **函数**  构造，析构
>
> 构造函数初始化对象成员，析构函数对象销毁前自动调用，用于清理   两者都会自动调用
>
> 语法
>
>  构造函数  **类名(){}**  无返回值也没有void 可以有参数所以可重载  无需手动能自动调用只会调用一次
>
>  析构函数  **~类名(){}** 无返回值也没void 没有参数所以不能重载   销毁前才会调用无需手动能自动调用只会调用一次 **不写也行** 编译器会自动创造
>
>   构造函数分为  **有参和无参**或者  **普通和拷贝** 
>
>    调用方式  括号
>
> ​        显示
>
> ​        隐式转换
>
> ​       类
>
> **括号法** 
>
>  Person p1;//默认构造函数的调用
>
>  Person p2(10);
>
>  Person p3(p2);
>
>  注意事项 调用默认构造函数的时候，不要加();  如果加了()，相当于是函数的声明
>
>  cout << p2.age<<endl;
>
>  cout << p3.age<<endl;
>
> 
>
>  **显示法**
>
>  Person p1;
>
>  Person p2 = Person(10);//有参构造
>
>  Person p3 = Person(p2);//拷贝构造
>
> 
>
>  Person(10);//匿名对象，当行执行结束后，系统会立即回收匿名对象
>
>  cout <<"aaaaaaaaaaaaaa"<<'\n';
>
> **隐式法**
>
>   Person p4 = 10;//相当于Person p4 = Person(10);
>
>   Person p5 = p4;//拷贝构造 
>
> 
>
> **拷贝构造函数使用时机** 
>
>   1.使用一个已经创建完毕的对象来初始化一个新对象 Person p2(p1) 
>
>    2.值传递的方式给函数参数传值 void dowork(Person p){}     void test02(){Person p;dowork(p)} 调用无参构造函数和拷贝构造函数
>
>    3.**值方式返回局部对象**Person dowork2(){Person p1;return p1} void test03(){Person p = dowork2()}调用无参构造函数和拷贝构造函数  **p1 和p是不同的  返回p1 的时候拷贝了p1的值让他为p2 ， 然后p=p2** 
>
>    如果用户**定义有参构造函数** c++ **不在**提供默认的**无参构造**，但是会提供默认拷贝构造
>
>    比如Person(int a){age = a},只写了这一个的话那么  Person b是错误的 但是Person b(10)是正确的
>
>    如果用户**定义拷贝构造函数**，那么**c++不会提供其他构造函数**
>
>    创建一个类的时候每个类都添加至少3钟函数 1.默认构造(空实现) 2.析构函数(空实现)  3.拷贝构造(值拷贝)
>
> **初始化列表**
>
> ```c++
> P(int a,int b,int c)
>   {
>     ma = a;
>     mb = b;
>     mc = c;
>   }
> P():ma(10),mb(20),mc(30){};//这样有点呆板可以这样该
> //可以
>     P(int a,int b,int c):ma(a),mb(b),mc(c){};
> 	int ma,mb,mc;
> //这样初始化的时候就不用p.ma = xx .......这样就可以
> Person p(10,20,30) 相当于 {
>     p.ma = 10;
>     p.mb = 20;
>     p.mc = 30;
> }
> 
> ```
>
> ## 深浅拷贝
>
> 如果使用**编译器提供**的拷贝函数那么就是浅拷贝
>
> 如果 属性里面有 指针类型，那么使用浅拷贝，可以会导致指针重复删除，导致内存泄漏
>
> 比如
>
> ```c++
> class Person
> {
>     public:
>   		int age;
>    		int *height;
>     	Person(int a,int h)
>         {
>             age = a;
>             height = new int(h);//在堆区开辟内存，并且让height指向这
>         }
>     	~Person()
>         {
>             if(height!=NULL)
>             {
>                 delete height;
>                 height = NULL;
>             }
>         }
>     //此时没有定义拷贝构造函数，那么编译器会提供，如果用到那么就是浅拷贝
>     Person(const Person &p)
>     {
>         age = p.age;
>         height = new int(*p.height);//让p2.height指向新的内存地址
>     }
> };
> Person p1(18,160);
>   cout << "p1的年龄和身高为:"<<p1.age<<' ' << *p1.m_Height<<endl;
>   Person p2(p1);
>   cout << "p2的年龄和身高为:"<<p1.age<<' ' << *p1.m_Height<<endl;
>   //Person p2(p1)如果利用编译器提供的拷贝函数(也就是自己没写！！！)，会做浅拷贝操作，使得堆区内存重复释放，比如有个p1内有成员是指针指向一个确定值的空间，然后p2进行(浅拷贝操作)那么会使p2的相应的指针指向同一个地址，然后在调用析构函数的时候会使得该地址被重复释放
>   //浅拷贝的问题可以利用深拷贝来解决是不同对象的指针指向不同地址，就不会重复释放
> ```
>
> ## 类可以作为另一个类的成员
>
> 比如
>
> ```c++
> class A{};
> class B
> {
>   A a;  
> };
> ```
>
> 当一个A类作为B类中的成员时，**先构造类成员**(即A)再构造自己(B)；
>
> **BUT**在析构的时候是先  **析构自身** 再析构类成员
>
> ### 对于静态成员变量
>
> 使用**static**修饰
>
> 1.所有对象共享同一份数据
>
> 2.在编译阶段分配内存
>
> 3.类内声明，类外初始化
>
> ### 对于静态成员函数
>
> 1.所有对象共享一个函数
>
> 2.静态函数只能访问静态成员变量
>
> 静态成员变量 不属于某个对象上，所有对象都共享一份数据
>
> 静态变量有两种访问方式
>
> 1.通过对象进行访问，2 通过类名进行访问 
>
> 1.比如Person p;  p.func();
>
> 2.比如Person::func();
>
> private:
>
>    static void func2()
>
>    {
>
> ​    cout << "func2的调用"<<endl;
>
>    }
>
> LH::func2();这是错误的  类外访问不到私有静态函数
>
> 
>
> 成员变量和成员函数是分开储存的
>
> 空对象占用内存空间为1
>
> c++编译器会给每个空对象也分配一个字节空间，是为了区分空对象占内存的位置
>
> 每个空对象也应该有一个独一无二的字节
>
> 
>
> int m_a;//非静态成员变量 属于类的对象上**即要占用类对象的空间**
>
>   static int m_b;//静态成员变量 不属于类的对象上
>
>   void func(){}// 非静态成员函数  不属于类对象上
>
> ### this指针
>
> **this指针指向被调用的成员函数所属对象**
>
> this不用定义
>
> 用途：
>
> 1.当形参和成员变量同名时，可用this指针来区分
>
> 2.在类的非静态成员函数返回对象本身时，可以使用 return *this
>
> ```c++
> class O
> {
>   public:
>     int age;
>     O(int age)
>     {
>       this->age = age;
>     }
>     O& oando(O &p)//返回本体要引用的返回，如果是返回值也就是没有&，那么是返回创建的一个新的对象
>     {
>       this->age+=p.age;
>       return *this;//返回的o2
>     }
> };
> 
> void test10()
> {
>   O o(18);
>   cout << o.age<<endl;
> }
> void test11()
> {
>   O o1(18);
>   O o2(18);
>   o2.oando(o1);
>   o2.oando(o1).oando(o1).oando(o1).oando(o1).oando(o1);//如果oando是void类型那么就不可以，but如果是返回类成员就OK啦
>     
>   cout << o1.age << endl;
>   cout << o2.age<< endl;
> }
> ```
>
> 空指针可以访问成员 
>
> 不过空指针如果调用成员变量的话会报错















